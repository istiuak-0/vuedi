{"version":3,"sources":["../src/functions/expose-children.ts","../src/libs/types.ts","../src/libs/registry.ts","../src/libs/service-refs.ts","../src/libs/service-token.ts","../src/libs/live-access/instance-properties.ts","../src/libs/live-access/instance-symbols.ts","../src/libs/live-access/prototype-properties.ts","../src/libs/live-access/static-properties.ts","../src/libs/live-access/static-symbols.ts","../src/functions/resolve.ts","../src/functions/resolve-context.ts","../src/functions/resolve-instance.ts","../src/register.decorator.ts","../src/vuedi.plugin.ts"],"sourcesContent":["import { getCurrentInstance, onScopeDispose, provide } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { getServiceRef } from '../libs/service-refs';\r\nimport { serviceRefView } from '../libs/registry';\r\nimport { getServiceToken } from '../libs/service-token';\r\n\r\nexport function exposeToChildren<T extends ServiceConstructor>(classOrInstance: T | InstanceType<T>): void {\r\n  let instance: InstanceType<T>;\r\n  let ownsInstance = false;\r\n\r\n  if (typeof classOrInstance === 'function') {\r\n    instance = new classOrInstance() as InstanceType<T>;\r\n    ownsInstance = true;\r\n  } else {\r\n    instance = classOrInstance;\r\n  }\r\n\r\n  const refView = getServiceRef(instance) as InstanceType<T>;\r\n  const serviceToken = getServiceToken(instance);\r\n  provide(serviceToken, refView);\r\n\r\n  if (ownsInstance) {\r\n    const componentInstance = getCurrentInstance();\r\n\r\n    if (componentInstance) {\r\n      onScopeDispose(() => {\r\n        if (ImplementsDispose(instance)) {\r\n          try {\r\n            (instance as ServiceWithDispose<T>).dispose();\r\n          } catch (error) {\r\n            console.error('[VUE DI]: Error in scope dispose:', error);\r\n          }\r\n        }\r\n\r\n        if (serviceRefView.has(instance)) {\r\n          serviceRefView.delete(instance);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n","export type ServiceConstructor<T extends object = object> = new () => T;\r\n\r\nexport interface Disposable {\r\n  dispose(): void;\r\n}\r\n\r\nexport function ImplementsDispose(instance: unknown) {\r\n  return typeof (instance as any).dispose === 'function';\r\n}\r\n\r\nexport type ServiceWithDispose<T> = T & {\r\n  dispose(): void;\r\n};\r\n\r\nexport type ServiceMetadata = {\r\n  token: symbol;\r\n};\r\n","import type { ServiceConstructor } from './types';\r\n\r\nexport const SERVICE_INTERNAL_METADATA = Symbol('VUEDI_SERVICE_METADATA');\r\nexport const serviceRegistry = new Map<symbol, object>();\r\nexport const serviceRefView = new WeakMap<InstanceType<ServiceConstructor>, any>();\r\n\r\n","import { serviceRefView } from './registry';\r\nimport { computed, isReactive, isRef, toRaw, toRef } from 'vue';\r\nimport type { ServiceConstructor } from './types';\r\n\r\nfunction serviceToRefs<T extends InstanceType<ServiceConstructor>>(service: T) {\r\n  const rawService = toRaw(service);\r\n  const refs: any = {};\r\n\r\n  /// loop through all object properties\r\n  for (const key in service) {\r\n    const value = rawService[key];\r\n\r\n    if (value != null && typeof value === 'object' && 'effect' in value) {\r\n      refs[key] = computed({\r\n        get: () => service[key],\r\n        set: newValue => {\r\n          service[key] = newValue;\r\n        },\r\n      });\r\n    } else if (isRef(value) || isReactive(value)) {\r\n      refs[key] = toRef(service, key);\r\n    } else if (typeof value === 'function') {\r\n      refs[key] = value.bind(service);\r\n    } else {\r\n      refs[key] = value;\r\n    }\r\n  }\r\n  return refs;\r\n}\r\n\r\nexport function getServiceRef<T extends InstanceType<ServiceConstructor>>(instance: T): T {\r\n  const cached = serviceRefView.get(instance);\r\n  if (cached) return cached;\r\n  const refs = serviceToRefs(instance);\r\n  serviceRefView.set(instance, refs);\r\n  return refs;\r\n}\r\n","import { SERVICE_INTERNAL_METADATA } from './registry';\r\nimport type { ServiceConstructor, ServiceMetadata } from './types';\r\n\r\nexport function getServiceToken(target: ServiceConstructor | object) {\r\n  const ctor = typeof target === 'function' ? target : target.constructor;\r\n\r\n  const meta = (ctor as any)[SERVICE_INTERNAL_METADATA] as ServiceMetadata;\r\n  if (!meta?.token) {\r\n    throw new Error(`[VUE DI]: ${ctor?.name || 'Unknown'} is not decorated with @Register()`);\r\n  }\r\n  return meta.token;\r\n}\r\n","import type { ServiceConstructor } from \"../types\";\r\n\r\n/**\r\n *  Copies All object properties\r\n *  to the resolved object .\r\n *\r\n * @export\r\n * @template {object} T\r\n * @param {InstanceType<ServiceConstructor<T>>} serviceInstance\r\n * @param {Record<PropertyKey, unknown>} targetObj\r\n */\r\nexport function addInstanceProperties<T extends object>(\r\n  serviceInstance: InstanceType<ServiceConstructor<T>>,\r\n  targetObj: Record<PropertyKey, unknown>\r\n) {\r\n  const instanceKeys = Object.getOwnPropertyNames(serviceInstance);\r\n\r\n  instanceKeys.forEach(key => {\r\n    if (key in targetObj) return;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(serviceInstance, key)!;\r\n\r\n    if (typeof descriptor.value === 'function') {\r\n      console.log('Instance method is in object keys instead of prototype');\r\n      return;\r\n    }\r\n\r\n    if (descriptor.get || descriptor.set) {\r\n      return;\r\n    }\r\n\r\n    Object.defineProperty(targetObj, key, {\r\n      get() {\r\n        return serviceInstance[key as keyof typeof serviceInstance];\r\n      },\r\n      set(v) {\r\n        serviceInstance[key as keyof typeof serviceInstance] = v;\r\n      },\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n  });\r\n}","import type { ServiceConstructor } from '../types';\r\n\r\n/**\r\n *  Copies All object Symbols\r\n *  to the resolved object\r\n *\r\n * @export\r\n * @template {object} T\r\n * @param {InstanceType<ServiceConstructor<T>>} serviceInstance\r\n * @param {Record<PropertyKey, unknown>} targetObj\r\n */\r\nexport function addInstanceSymbols<T extends object>(\r\n  serviceInstance: InstanceType<ServiceConstructor<T>>,\r\n  targetObj: Record<PropertyKey, unknown>\r\n) {\r\n  const instanceSymbolKeys = Object.getOwnPropertySymbols(serviceInstance);\r\n\r\n  instanceSymbolKeys.forEach(key => {\r\n    Object.defineProperty(targetObj, key, {\r\n      get() {\r\n        return serviceInstance[key as keyof typeof serviceInstance];\r\n      },\r\n      set(v) {\r\n        serviceInstance[key as keyof typeof serviceInstance] = v;\r\n      },\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n  });\r\n}\r\n","/**\r\n *  Copies All Prototype members (methods, accessors, and properties) from a object ( service instance )\r\n *  to the resolved object .\r\n *\r\n * @export\r\n * @template {object} T\r\n * @param {InstanceType<ServiceConstructor<T>>} serviceInstance\r\n * @param {Record<PropertyKey, unknown>} targetObj\r\n */\r\nexport function addPrototypeProperties<T extends object>(\r\n  serviceInstance: InstanceType<ServiceConstructor<T>>,\r\n  targetObj: Record<PropertyKey, unknown>\r\n) {\r\n  let currentProto = Object.getPrototypeOf(serviceInstance);\r\n\r\n  /// Loop Over The Whole Prototype Chain To Get All inherited Properties\r\n  while (currentProto && currentProto !== Object.prototype) {\r\n    const protoKeys = Object.getOwnPropertyNames(currentProto);\r\n    const filteredKeys = protoKeys.filter(key => key !== 'constructor');\r\n\r\n    filteredKeys.forEach(key => {\r\n      if (hasKey(targetObj, key)) return;\r\n\r\n      const descriptor = Object.getOwnPropertyDescriptor(currentProto, key)!;\r\n\r\n      if (descriptor.get || descriptor.set) {\r\n        const newDesc: PropertyDescriptor = {\r\n          enumerable: true,\r\n          configurable: true,\r\n        };\r\n\r\n        if (descriptor.get) {\r\n          newDesc.get = () => descriptor.get!.call(serviceInstance);\r\n        }\r\n\r\n        if (descriptor.set) {\r\n          newDesc.set = (value: any) => descriptor.set!.call(serviceInstance, value);\r\n        }\r\n\r\n        Object.defineProperty(targetObj, key, newDesc);\r\n      } else if (typeof descriptor.value === 'function') {\r\n        targetObj[key as keyof typeof targetObj] = descriptor.value.bind(serviceInstance);\r\n      }\r\n      // } else {\r\n      //   Object.defineProperty(targetObj, key, {\r\n      //     get() {\r\n      //       return serviceInstance[key as keyof typeof serviceInstance];\r\n      //     },\r\n      //     set(v) {\r\n      //       serviceInstance[key as keyof typeof serviceInstance] = v;\r\n      //     },\r\n      //     enumerable: true,\r\n      //     configurable: true,\r\n      //   });\r\n      // }\r\n    });\r\n\r\n    currentProto = Object.getPrototypeOf(currentProto);\r\n  }\r\n}","import type { ServiceConstructor } from \"../types\";\r\n\r\n/**\r\n * Copies static members (methods, accessors, and properties) from a service class\r\n * to the resolved object, preserving correct context and reactivity.\r\n *\r\n * @export\r\n * @template {object} T\r\n * @param {ServiceConstructor<T>} serviceClass\r\n * @param {Record<PropertyKey, unknown>} targetObj\r\n */\r\nexport function addStaticProperties<T extends object>(\r\n  serviceClass: ServiceConstructor<T>,\r\n  targetObj: Record<PropertyKey, unknown>\r\n): void {\r\n  const allStaticKeys = Object.getOwnPropertyNames(serviceClass);\r\n\r\n  const userDefinedStaticKeys = allStaticKeys.filter(key => !['length', 'name', 'prototype'].includes(key));\r\n\r\n  userDefinedStaticKeys.forEach(key => {\r\n    const descriptor = Object.getOwnPropertyDescriptor(serviceClass, key)!;\r\n\r\n    if (typeof descriptor.value === 'function') {\r\n      targetObj[key] = descriptor.value.bind(serviceClass);\r\n    } else if (descriptor.get || descriptor.set) {\r\n      const newDesc: PropertyDescriptor = {\r\n        enumerable: true,\r\n        configurable: true,\r\n      };\r\n\r\n      if (descriptor.get) {\r\n        newDesc.get = () => descriptor.get!.call(serviceClass);\r\n      }\r\n\r\n      if (descriptor.set) {\r\n        newDesc.set = (value: any) => descriptor.set!.call(serviceClass, value);\r\n      }\r\n\r\n      Object.defineProperty(targetObj, key, newDesc);\r\n    } else {\r\n      Object.defineProperty(targetObj, key, {\r\n        get() {\r\n          return serviceClass[key as keyof typeof serviceClass];\r\n        },\r\n        set(v) {\r\n          (serviceClass[key as keyof typeof serviceClass] as unknown) = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n    }\r\n  });\r\n}\r\n","import type { ServiceConstructor } from \"../types\";\r\n\r\n/**\r\n *  Copies All static symbols\r\n *  to the resolved object .\r\n *\r\n * @export\r\n * @template {object} T\r\n * @param {ServiceConstructor<T>} serviceClass\r\n * @param {Record<PropertyKey, unknown>} targeObj\r\n */\r\nexport function addStaticSymbols<T extends object>(\r\n  serviceClass: ServiceConstructor<T>,\r\n  targeObj: Record<PropertyKey, unknown>\r\n) {\r\n  const staticSymbolKeys = Object.getOwnPropertySymbols(serviceClass);\r\n\r\n  staticSymbolKeys.forEach(key => {\r\n    const descriptor = Object.getOwnPropertyDescriptor(serviceClass, key)!;\r\n\r\n    if (typeof descriptor.value === 'function') {\r\n      targeObj[key] = descriptor.value.bind(serviceClass);\r\n    } else if (descriptor.get || descriptor.set) {\r\n      const newDesc: PropertyDescriptor = {\r\n        enumerable: true,\r\n        configurable: true,\r\n      };\r\n\r\n      if (descriptor.get) {\r\n        newDesc.get = () => descriptor.get!.call(serviceClass);\r\n      }\r\n\r\n      if (descriptor.set) {\r\n        newDesc.set = (value: any) => descriptor.set!.call(serviceClass, value);\r\n      }\r\n\r\n      Object.defineProperty(targeObj, key, newDesc);\r\n    } else {\r\n      Object.defineProperty(targeObj, key, {\r\n        get() {\r\n          return serviceClass[key as keyof typeof serviceClass];\r\n        },\r\n        set(v) {\r\n          (serviceClass[key as keyof typeof serviceClass] as unknown) = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n    }\r\n  });\r\n}","import { addInstanceProperties } from '../libs/live-access/instance-properties';\r\nimport { addInstanceSymbols } from '../libs/live-access/instance-symbols';\r\nimport { addPrototypeProperties } from '../libs/live-access/prototype-properties';\r\nimport { addStaticProperties } from '../libs/live-access/static-properties';\r\nimport { addStaticSymbols } from '../libs/live-access/static-symbols';\r\nimport { serviceRegistry } from '../libs/registry';\r\nimport { getServiceToken } from '../libs/service-token';\r\nimport type { ServiceConstructor } from '../libs/types';\r\n\r\ntype ResolvedService<T extends ServiceConstructor> = {\r\n  [K in keyof InstanceType<T>]: InstanceType<T>[K];\r\n} & {\r\n  [K in keyof T]: T[K];\r\n};\r\n\r\n/**\r\n * Resolves a global singleton service into a destructurable object with:\r\n * - Live getters for reactive state (ref, computed, etc.)\r\n * - Bound methods that preserve correct `this` context\r\n *\r\n * @export\r\n * @template {ServiceConstructor} T\r\n * @param {T} serviceClass\r\n * @returns {InstanceType<T>}\r\n */\r\nexport function resolve<T extends ServiceConstructor>(serviceClass: T) {\r\n  const serviceToken = getServiceToken(serviceClass);\r\n\r\n  // Ensure singleton: create once, reuse forever\r\n  if (!serviceRegistry.has(serviceToken)) {\r\n    serviceRegistry.set(serviceToken, new serviceClass());\r\n  }\r\n\r\n  const instance = serviceRegistry.get(serviceToken)!;\r\n  const obj: Record<string, any> = {};\r\n\r\n  addStaticProperties(serviceClass, obj);\r\n  addStaticSymbols(serviceClass, obj);\r\n\r\n  addInstanceProperties(instance, obj);\r\n  addInstanceSymbols(instance, obj);\r\n\r\n  addPrototypeProperties(instance, obj);\r\n\r\n  return obj as ResolvedService<T>;\r\n}\r\n","import { inject } from 'vue';\r\nimport type { ServiceConstructor } from '../libs/types';\r\nimport { getServiceToken } from '../libs/service-token';\r\n\r\nexport function resolveFromContext<T extends ServiceConstructor>(serviceClass: T) {\r\n  const serviceToken = getServiceToken(serviceClass);\r\n  return inject<InstanceType<T>>(serviceToken);\r\n}\r\n","import { getCurrentInstance, onScopeDispose } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { serviceRefView } from '../libs/registry';\r\n\r\nexport function resolveInstance<T extends ServiceConstructor>(serviceClass: T): InstanceType<T> {\r\n  let instance = new serviceClass();\r\n  const componentInstance = getCurrentInstance();\r\n\r\n\r\n/// here if i want i can tap into other hooks\r\n  if (componentInstance) {\r\n    onScopeDispose(() => {\r\n      if (ImplementsDispose(instance)) {\r\n        try {\r\n          (instance as ServiceWithDispose<typeof instance>).dispose();\r\n        } catch (error) {\r\n          console.error('[VUE DI]: Error in scope dispose:', error);\r\n        }\r\n      }\r\n\r\n      if (serviceRefView.has(instance)) {\r\n        serviceRefView.delete(instance);\r\n      }\r\n    });\r\n  }\r\n  return instance as InstanceType<T>;\r\n}\r\n","import { SERVICE_INTERNAL_METADATA } from './libs/registry';\r\nimport type { ServiceConstructor } from './libs/types';\r\n\r\nexport function Register() {\r\n  return function <C extends ServiceConstructor>(constructor: C) {\r\n    // Its Already Registered\r\n    if ((constructor as any)[SERVICE_INTERNAL_METADATA]?.token) {\r\n      return constructor;\r\n    }\r\n\r\n    const token = Symbol(`vuedi:service:${constructor.name || 'Anonymous'}`);\r\n    (constructor as any)[SERVICE_INTERNAL_METADATA] = { token };\r\n    return constructor;\r\n  };\r\n}\r\n","import type { FunctionPlugin } from 'vue';\r\nimport { serviceRegistry } from './libs/registry';\r\nimport { getServiceToken } from './libs/service-token';\r\nimport type { ServiceConstructor } from './libs/types';\r\n\r\ntype VueDIOptions = {\r\n  services: ServiceConstructor[];\r\n};\r\n\r\nexport const vuediPlugin: FunctionPlugin<[Partial<VueDIOptions>?]> = (_app, options?: Partial<VueDIOptions>) => {\r\n  ///Eagerly create instances\r\n  if (options?.services) {\r\n    options.services.forEach(item => {\r\n      const serviceToken = getServiceToken(item);\r\n\r\n      const serviceInstance = serviceRegistry.has(serviceToken);\r\n      if (!serviceInstance) {\r\n        serviceRegistry.set(serviceToken, new item());\r\n      }\r\n    });\r\n  }\r\n};\r\n"],"mappings":";;;AAAA,SAAS,oBAAoB,gBAAgB,eAAe;;;ACMrD,SAAS,kBAAkB,UAAmB;AACnD,SAAO,OAAQ,SAAiB,YAAY;AAC9C;;;ACNO,IAAM,4BAA4B,uBAAO,wBAAwB;AACjE,IAAM,kBAAkB,oBAAI,IAAoB;AAChD,IAAM,iBAAiB,oBAAI,QAA+C;;;ACHjF,SAAS,UAAU,YAAY,OAAO,OAAO,aAAa;AAG1D,SAAS,cAA0D,SAAY;AAC7E,QAAM,aAAa,MAAM,OAAO;AAChC,QAAM,OAAY,CAAC;AAGnB,aAAW,OAAO,SAAS;AACzB,UAAM,QAAQ,WAAW,GAAG;AAE5B,QAAI,SAAS,QAAQ,OAAO,UAAU,YAAY,YAAY,OAAO;AACnE,WAAK,GAAG,IAAI,SAAS;AAAA,QACnB,KAAK,MAAM,QAAQ,GAAG;AAAA,QACtB,KAAK,cAAY;AACf,kBAAQ,GAAG,IAAI;AAAA,QACjB;AAAA,MACF,CAAC;AAAA,IACH,WAAW,MAAM,KAAK,KAAK,WAAW,KAAK,GAAG;AAC5C,WAAK,GAAG,IAAI,MAAM,SAAS,GAAG;AAAA,IAChC,WAAW,OAAO,UAAU,YAAY;AACtC,WAAK,GAAG,IAAI,MAAM,KAAK,OAAO;AAAA,IAChC,OAAO;AACL,WAAK,GAAG,IAAI;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,cAA0D,UAAgB;AACxF,QAAM,SAAS,eAAe,IAAI,QAAQ;AAC1C,MAAI,OAAQ,QAAO;AACnB,QAAM,OAAO,cAAc,QAAQ;AACnC,iBAAe,IAAI,UAAU,IAAI;AACjC,SAAO;AACT;;;ACjCO,SAAS,gBAAgB,QAAqC;AACnE,QAAM,OAAO,OAAO,WAAW,aAAa,SAAS,OAAO;AAE5D,QAAM,OAAQ,KAAa,yBAAyB;AACpD,MAAI,CAAC,MAAM,OAAO;AAChB,UAAM,IAAI,MAAM,aAAa,MAAM,QAAQ,SAAS,oCAAoC;AAAA,EAC1F;AACA,SAAO,KAAK;AACd;;;AJLO,SAAS,iBAA+C,iBAA4C;AACzG,MAAI;AACJ,MAAI,eAAe;AAEnB,MAAI,OAAO,oBAAoB,YAAY;AACzC,eAAW,IAAI,gBAAgB;AAC/B,mBAAe;AAAA,EACjB,OAAO;AACL,eAAW;AAAA,EACb;AAEA,QAAM,UAAU,cAAc,QAAQ;AACtC,QAAM,eAAe,gBAAgB,QAAQ;AAC7C,UAAQ,cAAc,OAAO;AAE7B,MAAI,cAAc;AAChB,UAAM,oBAAoB,mBAAmB;AAE7C,QAAI,mBAAmB;AACrB,qBAAe,MAAM;AACnB,YAAI,kBAAkB,QAAQ,GAAG;AAC/B,cAAI;AACF,YAAC,SAAmC,QAAQ;AAAA,UAC9C,SAAS,OAAO;AACd,oBAAQ,MAAM,qCAAqC,KAAK;AAAA,UAC1D;AAAA,QACF;AAEA,YAAI,eAAe,IAAI,QAAQ,GAAG;AAChC,yBAAe,OAAO,QAAQ;AAAA,QAChC;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;AK7BO,SAAS,sBACd,iBACA,WACA;AACA,QAAM,eAAe,OAAO,oBAAoB,eAAe;AAE/D,eAAa,QAAQ,SAAO;AAC1B,QAAI,OAAO,UAAW;AAEtB,UAAM,aAAa,OAAO,yBAAyB,iBAAiB,GAAG;AAEvE,QAAI,OAAO,WAAW,UAAU,YAAY;AAC1C,cAAQ,IAAI,wDAAwD;AACpE;AAAA,IACF;AAEA,QAAI,WAAW,OAAO,WAAW,KAAK;AACpC;AAAA,IACF;AAEA,WAAO,eAAe,WAAW,KAAK;AAAA,MACpC,MAAM;AACJ,eAAO,gBAAgB,GAAmC;AAAA,MAC5D;AAAA,MACA,IAAI,GAAG;AACL,wBAAgB,GAAmC,IAAI;AAAA,MACzD;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAChB,CAAC;AAAA,EACH,CAAC;AACH;;;AC/BO,SAAS,mBACd,iBACA,WACA;AACA,QAAM,qBAAqB,OAAO,sBAAsB,eAAe;AAEvE,qBAAmB,QAAQ,SAAO;AAChC,WAAO,eAAe,WAAW,KAAK;AAAA,MACpC,MAAM;AACJ,eAAO,gBAAgB,GAAmC;AAAA,MAC5D;AAAA,MACA,IAAI,GAAG;AACL,wBAAgB,GAAmC,IAAI;AAAA,MACzD;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAChB,CAAC;AAAA,EACH,CAAC;AACH;;;ACpBO,SAAS,uBACd,iBACA,WACA;AACA,MAAI,eAAe,OAAO,eAAe,eAAe;AAGxD,SAAO,gBAAgB,iBAAiB,OAAO,WAAW;AACxD,UAAM,YAAY,OAAO,oBAAoB,YAAY;AACzD,UAAM,eAAe,UAAU,OAAO,SAAO,QAAQ,aAAa;AAElE,iBAAa,QAAQ,SAAO;AAC1B,UAAI,OAAO,WAAW,GAAG,EAAG;AAE5B,YAAM,aAAa,OAAO,yBAAyB,cAAc,GAAG;AAEpE,UAAI,WAAW,OAAO,WAAW,KAAK;AACpC,cAAM,UAA8B;AAAA,UAClC,YAAY;AAAA,UACZ,cAAc;AAAA,QAChB;AAEA,YAAI,WAAW,KAAK;AAClB,kBAAQ,MAAM,MAAM,WAAW,IAAK,KAAK,eAAe;AAAA,QAC1D;AAEA,YAAI,WAAW,KAAK;AAClB,kBAAQ,MAAM,CAAC,UAAe,WAAW,IAAK,KAAK,iBAAiB,KAAK;AAAA,QAC3E;AAEA,eAAO,eAAe,WAAW,KAAK,OAAO;AAAA,MAC/C,WAAW,OAAO,WAAW,UAAU,YAAY;AACjD,kBAAU,GAA6B,IAAI,WAAW,MAAM,KAAK,eAAe;AAAA,MAClF;AAAA,IAaF,CAAC;AAED,mBAAe,OAAO,eAAe,YAAY;AAAA,EACnD;AACF;;;AChDO,SAAS,oBACd,cACA,WACM;AACN,QAAM,gBAAgB,OAAO,oBAAoB,YAAY;AAE7D,QAAM,wBAAwB,cAAc,OAAO,SAAO,CAAC,CAAC,UAAU,QAAQ,WAAW,EAAE,SAAS,GAAG,CAAC;AAExG,wBAAsB,QAAQ,SAAO;AACnC,UAAM,aAAa,OAAO,yBAAyB,cAAc,GAAG;AAEpE,QAAI,OAAO,WAAW,UAAU,YAAY;AAC1C,gBAAU,GAAG,IAAI,WAAW,MAAM,KAAK,YAAY;AAAA,IACrD,WAAW,WAAW,OAAO,WAAW,KAAK;AAC3C,YAAM,UAA8B;AAAA,QAClC,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB;AAEA,UAAI,WAAW,KAAK;AAClB,gBAAQ,MAAM,MAAM,WAAW,IAAK,KAAK,YAAY;AAAA,MACvD;AAEA,UAAI,WAAW,KAAK;AAClB,gBAAQ,MAAM,CAAC,UAAe,WAAW,IAAK,KAAK,cAAc,KAAK;AAAA,MACxE;AAEA,aAAO,eAAe,WAAW,KAAK,OAAO;AAAA,IAC/C,OAAO;AACL,aAAO,eAAe,WAAW,KAAK;AAAA,QACpC,MAAM;AACJ,iBAAO,aAAa,GAAgC;AAAA,QACtD;AAAA,QACA,IAAI,GAAG;AACL,UAAC,aAAa,GAAgC,IAAgB;AAAA,QAChE;AAAA,QACA,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;;;ACzCO,SAAS,iBACd,cACA,UACA;AACA,QAAM,mBAAmB,OAAO,sBAAsB,YAAY;AAElE,mBAAiB,QAAQ,SAAO;AAC9B,UAAM,aAAa,OAAO,yBAAyB,cAAc,GAAG;AAEpE,QAAI,OAAO,WAAW,UAAU,YAAY;AAC1C,eAAS,GAAG,IAAI,WAAW,MAAM,KAAK,YAAY;AAAA,IACpD,WAAW,WAAW,OAAO,WAAW,KAAK;AAC3C,YAAM,UAA8B;AAAA,QAClC,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB;AAEA,UAAI,WAAW,KAAK;AAClB,gBAAQ,MAAM,MAAM,WAAW,IAAK,KAAK,YAAY;AAAA,MACvD;AAEA,UAAI,WAAW,KAAK;AAClB,gBAAQ,MAAM,CAAC,UAAe,WAAW,IAAK,KAAK,cAAc,KAAK;AAAA,MACxE;AAEA,aAAO,eAAe,UAAU,KAAK,OAAO;AAAA,IAC9C,OAAO;AACL,aAAO,eAAe,UAAU,KAAK;AAAA,QACnC,MAAM;AACJ,iBAAO,aAAa,GAAgC;AAAA,QACtD;AAAA,QACA,IAAI,GAAG;AACL,UAAC,aAAa,GAAgC,IAAgB;AAAA,QAChE;AAAA,QACA,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;;;ACzBO,SAAS,QAAsC,cAAiB;AACrE,QAAM,eAAe,gBAAgB,YAAY;AAGjD,MAAI,CAAC,gBAAgB,IAAI,YAAY,GAAG;AACtC,oBAAgB,IAAI,cAAc,IAAI,aAAa,CAAC;AAAA,EACtD;AAEA,QAAM,WAAW,gBAAgB,IAAI,YAAY;AACjD,QAAM,MAA2B,CAAC;AAElC,sBAAoB,cAAc,GAAG;AACrC,mBAAiB,cAAc,GAAG;AAElC,wBAAsB,UAAU,GAAG;AACnC,qBAAmB,UAAU,GAAG;AAEhC,yBAAuB,UAAU,GAAG;AAEpC,SAAO;AACT;;;AC7CA,SAAS,cAAc;AAIhB,SAAS,mBAAiD,cAAiB;AAChF,QAAM,eAAe,gBAAgB,YAAY;AACjD,SAAO,OAAwB,YAAY;AAC7C;;;ACPA,SAAS,sBAAAA,qBAAoB,kBAAAC,uBAAsB;AAI5C,SAAS,gBAA8C,cAAkC;AAC9F,MAAI,WAAW,IAAI,aAAa;AAChC,QAAM,oBAAoBC,oBAAmB;AAI7C,MAAI,mBAAmB;AACrB,IAAAC,gBAAe,MAAM;AACnB,UAAI,kBAAkB,QAAQ,GAAG;AAC/B,YAAI;AACF,UAAC,SAAiD,QAAQ;AAAA,QAC5D,SAAS,OAAO;AACd,kBAAQ,MAAM,qCAAqC,KAAK;AAAA,QAC1D;AAAA,MACF;AAEA,UAAI,eAAe,IAAI,QAAQ,GAAG;AAChC,uBAAe,OAAO,QAAQ;AAAA,MAChC;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT;;;ACvBO,SAAS,WAAW;AACzB,SAAO,SAAwC,aAAgB;AAE7D,QAAK,YAAoB,yBAAyB,GAAG,OAAO;AAC1D,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,uBAAO,iBAAiB,YAAY,QAAQ,WAAW,EAAE;AACvE,IAAC,YAAoB,yBAAyB,IAAI,EAAE,MAAM;AAC1D,WAAO;AAAA,EACT;AACF;;;ACLO,IAAM,cAAwD,CAAC,MAAM,YAAoC;AAE9G,MAAI,SAAS,UAAU;AACrB,YAAQ,SAAS,QAAQ,UAAQ;AAC/B,YAAM,eAAe,gBAAgB,IAAI;AAEzC,YAAM,kBAAkB,gBAAgB,IAAI,YAAY;AACxD,UAAI,CAAC,iBAAiB;AACpB,wBAAgB,IAAI,cAAc,IAAI,KAAK,CAAC;AAAA,MAC9C;AAAA,IACF,CAAC;AAAA,EACH;AACF;","names":["getCurrentInstance","onScopeDispose","getCurrentInstance","onScopeDispose"]}