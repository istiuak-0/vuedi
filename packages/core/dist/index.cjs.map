{"version":3,"sources":["../src/index.ts","../src/libs/registry.ts","../src/decorators/register.ts","../src/functions/expose-children.ts","../src/libs/types.ts","../src/libs/service-refs.ts","../src/libs/service-token.ts","../src/functions/resolve.ts","../src/functions/resolve-context.ts","../src/functions/resolve-instance.ts","../src/plugin/vuedi.plugin.ts"],"sourcesContent":["export * from './decorators/register';\r\nexport * from './functions/expose-children';\r\nexport * from './functions/resolve';\r\nexport * from './functions/resolve-context';\r\nexport * from './functions/resolve-instance';\r\nexport * from './libs/registry';\r\nexport * from './libs/service-refs';\r\nexport * from './libs/types';\r\nexport * from './plugin/vuedi.plugin';\r\n\r\n","import type { ServiceConstructor } from './types';\r\n\r\nexport const SERVICE_INTERNAL_METADATA = Symbol('VUEDI_SERVICE_METADATA');\r\nexport const serviceRegistry = new Map<symbol, any>();\r\nexport const serviceRefView = new WeakMap<InstanceType<ServiceConstructor>, any>();\r\n\r\n","import { SERVICE_INTERNAL_METADATA } from '../libs/registry';\r\nimport type { ServiceConstructor } from '../libs/types';\r\n\r\nexport function Register() {\r\n  return function <C extends ServiceConstructor>(constructor: C) {\r\n    // Its Already Registered\r\n    if ((constructor as any)[SERVICE_INTERNAL_METADATA]?.token) {\r\n      return constructor;\r\n    }\r\n\r\n    const token = Symbol(`vuedi:service:${constructor.name || 'Anonymous'}`);\r\n    (constructor as any)[SERVICE_INTERNAL_METADATA] = { token };\r\n    return constructor;\r\n  };\r\n}\r\n","import { getCurrentInstance, onScopeDispose, provide } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { getServiceRef } from '../libs/service-refs';\r\nimport { serviceRefView } from '../libs/registry';\r\nimport { getServiceToken } from '../libs/service-token';\r\n\r\nexport function exposeToChildren<T extends ServiceConstructor>(classOrInstance: T | InstanceType<T>): void {\r\n  let instance: InstanceType<T>;\r\n  let ownsInstance = false;\r\n\r\n  if (typeof classOrInstance === 'function') {\r\n    instance = new classOrInstance() as InstanceType<T>;\r\n    ownsInstance = true;\r\n  } else {\r\n    instance = classOrInstance;\r\n  }\r\n\r\n  const refView = getServiceRef(instance) as InstanceType<T>;\r\n  const serviceToken = getServiceToken(instance);\r\n  provide(serviceToken, refView);\r\n\r\n  if (ownsInstance) {\r\n    const componentInstance = getCurrentInstance();\r\n\r\n    if (componentInstance) {\r\n      onScopeDispose(() => {\r\n        if (ImplementsDispose(instance)) {\r\n          try {\r\n            (instance as ServiceWithDispose<T>).dispose();\r\n          } catch (error) {\r\n            console.error('[VUE DI]: Error in scope dispose:', error);\r\n          }\r\n        }\r\n\r\n        if (serviceRefView.has(instance)) {\r\n          serviceRefView.delete(instance);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n","export type ServiceConstructor<T extends object = object> = new () => T;\r\n\r\nexport interface Disposable {\r\n  dispose(): void;\r\n}\r\n\r\nexport function ImplementsDispose(instance: unknown) {\r\n  return typeof (instance as any).dispose === 'function';\r\n}\r\n\r\nexport type ServiceWithDispose<T> = T & {\r\n  dispose(): void;\r\n};\r\n\r\nexport type ServiceMetadata = {\r\n  token: symbol;\r\n};\r\n","import { serviceRefView } from './registry';\r\nimport { computed, isReactive, isRef, toRaw, toRef } from 'vue';\r\nimport type { ServiceConstructor } from './types';\r\n\r\nfunction serviceToRefs<T extends InstanceType<ServiceConstructor>>(service: T) {\r\n  const rawService = toRaw(service);\r\n  const refs: any = {};\r\n\r\n  /// loop through all object properties\r\n  for (const key in service) {\r\n    const value = rawService[key];\r\n\r\n    if (value != null && typeof value === 'object' && 'effect' in value) {\r\n      refs[key] = computed({\r\n        get: () => service[key],\r\n        set: newValue => {\r\n          service[key] = newValue;\r\n        },\r\n      });\r\n    } else if (isRef(value) || isReactive(value)) {\r\n      refs[key] = toRef(service, key);\r\n    } else if (typeof value === 'function') {\r\n      refs[key] = value.bind(service);\r\n    } else {\r\n      refs[key] = value;\r\n    }\r\n  }\r\n  return refs;\r\n}\r\n\r\nexport function getServiceRef<T extends InstanceType<ServiceConstructor>>(instance: T): T {\r\n  const cached = serviceRefView.get(instance);\r\n  if (cached) return cached;\r\n  const refs = serviceToRefs(instance);\r\n  serviceRefView.set(instance, refs);\r\n  return refs;\r\n}\r\n","import { SERVICE_INTERNAL_METADATA } from './registry';\r\nimport type { ServiceConstructor, ServiceMetadata } from './types';\r\n\r\nexport function getServiceToken(target: ServiceConstructor | object) {\r\n  const ctor = typeof target === 'function' ? target : target.constructor;\r\n\r\n  const meta = (ctor as any)[SERVICE_INTERNAL_METADATA] as ServiceMetadata;\r\n  if (!meta?.token) {\r\n    throw new Error(`[VUE DI]: ${ctor?.name || 'Unknown'} is not decorated with @Register()`);\r\n  }\r\n  return meta.token;\r\n}\r\n","import { serviceRegistry } from '../libs/registry';\r\nimport { getServiceToken } from '../libs/service-token';\r\nimport { type ServiceConstructor } from '../libs/types';\r\n\r\n/// this will only be used fro global services\r\nexport function resolve<T extends ServiceConstructor>(serviceClass: T) {\r\n  const serviceToken = getServiceToken(serviceClass);\r\n\r\n  if (!serviceRegistry.has(serviceToken)) {\r\n    serviceRegistry.set(serviceToken, new serviceClass());\r\n  }\r\n\r\n  let instance = serviceRegistry.get(serviceToken);\r\n  const obj: Record<string, any> = {};\r\n\r\n  for (const key in instance) {\r\n    Object.defineProperty(obj, key, {\r\n      get: () => (instance as any)[key],\r\n      enumerable: true,\r\n    });\r\n  }\r\n\r\n  let proto = instance;\r\n  while ((proto = Object.getPrototypeOf(proto)) && proto !== Object.prototype) {\r\n    for (const name of Object.getOwnPropertyNames(proto)) {\r\n      if (name !== 'constructor' && !(name in obj)) {\r\n        const value = (proto as any)[name];\r\n        if (typeof value === 'function') {\r\n          obj[name] = value.bind(instance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj as InstanceType<T>;\r\n}\r\n","import { inject } from 'vue';\r\nimport type { ServiceConstructor } from '../libs/types';\r\nimport { getServiceToken } from '../libs/service-token';\r\n\r\nexport function resolveFromContext<T extends ServiceConstructor>(serviceClass: T) {\r\n  const serviceToken = getServiceToken(serviceClass);\r\n  return inject<InstanceType<T>>(serviceToken);\r\n}\r\n","import { getCurrentInstance, onScopeDispose } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { serviceRefView } from '../libs/registry';\r\nimport { getServiceRef } from '../libs/service-refs';\r\n\r\nexport function resolveInstance<T extends ServiceConstructor>(serviceClass: T): InstanceType<T> {\r\n  let instance = new serviceClass();\r\n  const componentInstance = getCurrentInstance();\r\n\r\n  if (componentInstance) {\r\n    onScopeDispose(() => {\r\n      if (ImplementsDispose(instance)) {\r\n        try {\r\n          (instance as ServiceWithDispose<typeof instance>).dispose();\r\n        } catch (error) {\r\n          console.error('[VUE DI]: Error in scope dispose:', error);\r\n        }\r\n      }\r\n\r\n      if (serviceRefView.has(instance)) {\r\n        serviceRefView.delete(instance);\r\n      }\r\n    });\r\n  }\r\n\r\n  return getServiceRef(instance) as InstanceType<T>;\r\n}\r\n","import type { FunctionPlugin } from 'vue';\r\nimport { serviceRegistry } from '../libs/registry';\r\nimport type { ServiceConstructor } from '../libs/types';\r\nimport { getServiceToken } from '../libs/service-token';\r\n\r\ntype VueDIOptions = {\r\n  services: ServiceConstructor[];\r\n};\r\n\r\nexport const vuediPlugin: FunctionPlugin<[Partial<VueDIOptions>?]> = (_app, options?: Partial<VueDIOptions>) => {\r\n  ///Eagerly create instances\r\n  if (options?.services) {\r\n    options.services.forEach(item => {\r\n      const serviceToken = getServiceToken(item);\r\n\r\n      const serviceInstance = serviceRegistry.has(serviceToken);\r\n      if (!serviceInstance) {\r\n        serviceRegistry.set(serviceToken, new item());\r\n      }\r\n    });\r\n  }\r\n};\r\n"],"mappings":"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","names":["import_vue","import_vue","import_vue"]}